/*
 * clockControl.c
 *
 *  Created on: Sep 28, 2016
 *      Author: cdmoo
 */
#include <stdio.h>
#include "clockDisplay.h"
#include "supportFiles/display.h"

#define ADC_COUNTER_MAX 50
#define AUTO_COUNTER_MAX 500
#define RATE_COUNTER_MAX 100
#define MAIN_CLOCK_COUNTER_MAX 1000

// States for the controller state machine.
enum clockControl_st_t {
    init_st,                 // Start here, stay in this state for just one tick.
    never_touched_st,        // Wait here until the first touch - clock is disabled until set.
    waiting_for_touch_st,    // waiting for touch, clock is enabled and running.
    adc_counter_running_st,     // waiting for the touch-controller ADC to settle.
    auto_counter_running_st,   // waiting for the auto-update delay to expire
                                 // (user is holding down button for auto-inc/dec)
    rate_counter_running_st,   // waiting for the rate-timer to expire to know when to perform the auto inc/dec.
    rate_counter_expired_st,   // when the rate-timer expires, perform the inc/dec function.
    add_second_to_clock_st   // add a second to the clock time and reset the ms counter.
} currentState = init_st;

static uint32_t adcCounter;
static uint32_t autoCounter;
static uint32_t rateCounter;
static uint32_t mainClockCounter;
void debugStatePrint();

void clockControl_tick() {
  // Perform state action first.
  switch(currentState) {
    case init_st:
      break;
    case never_touched_st:
        adcCounter = 0;
        autoCounter = 0;
        rateCounter = 0;
        mainClockCounter = 0;
        break;
    case waiting_for_touch_st:
        adcCounter = 0;
        autoCounter = 0;
        rateCounter = 0;
        mainClockCounter++;
        break;
    case adc_counter_running_st:
        adcCounter++;
        break;
    case auto_counter_running_st:
        autoCounter++;
        break;
    case rate_counter_running_st:
        rateCounter++;
        break;
    case rate_counter_expired_st:
        rateCounter = 0;
        break;
    case add_second_to_clock_st:
        mainClockCounter = 0;
        break;
    default:
        printf("clockControl_tick state action: hit default\n\r");
        break;
  }

  // Perform state update next.
  switch(currentState) {
    case init_st:
        currentState = never_touched_st;
        break;
    case never_touched_st:
        if(display_isTouched()) {
            display_clearOldTouchData();
            currentState = adc_counter_running_st;
        }
        break;
    case waiting_for_touch_st:
        if(display_isTouched()) {
            display_clearOldTouchData();
            currentState = adc_counter_running_st;
        }
        else if(mainClockCounter == MAIN_CLOCK_COUNTER_MAX) {
            currentState = add_second_to_clock_st;
        }
        break;
    case adc_counter_running_st:
        if(!display_isTouched() && adcCounter == ADC_COUNTER_MAX) {
            clockDisplay_performIncDec();
            currentState = waiting_for_touch_st;
        }
        else if(display_isTouched() && adcCounter == ADC_COUNTER_MAX) {
            currentState = auto_counter_running_st;
        }
        break;
    case auto_counter_running_st:
        if(!display_isTouched()) {
            clockDisplay_performIncDec();
            currentState = waiting_for_touch_st;
        }
        else if(display_isTouched() && autoCounter == AUTO_COUNTER_MAX) {
            clockDisplay_performIncDec();
            currentState = rate_counter_running_st;
        }
        break;
    case rate_counter_running_st:
        if(!display_isTouched()) {
            currentState = waiting_for_touch_st;
        }
        else if(display_isTouched() && rateCounter == RATE_COUNTER_MAX) {
            currentState = rate_counter_expired_st;
        }
        break;
    case rate_counter_expired_st:
        if(!display_isTouched()) {
            currentState = waiting_for_touch_st;
        }
        else if(display_isTouched()) {
            clockDisplay_performIncDec();
            currentState = rate_counter_running_st;
        }
        break;
    case add_second_to_clock_st:
        clockDisplay_advanceTimeOneSecond();
        currentState = waiting_for_touch_st;
        break;
    default:
        printf("clockControl_tick state update: hit default\n\r");
        break;
  }

  debugStatePrint();
}


// This is a debug state print routine. It will print the names of the states each
// time tick() is called. It only prints states if they are different than the
// previous state.
void debugStatePrint() {
  static clockControl_st_t previousState;
  static bool firstPass = true;
  // Only print the message if:
  // 1. This the first pass and the value for previousState is unknown.
  // 2. previousState != currentState - this prevents reprinting the same state name over and over.
  if (previousState != currentState || firstPass) {
    firstPass = false;                // previousState will be defined, firstPass is false.
    previousState = currentState;     // keep track of the last state that you were in.
    switch(currentState) {            // This prints messages based upon the state that you were in.
      case init_st:
        printf("init_st\n\r");
        break;
      case never_touched_st:
        printf("never_touched_st\n\r");
        break;
      case waiting_for_touch_st:
        printf("waiting_for_touch_st\n\r");
        break;
      case adc_counter_running_st:
        printf("ad_timer_running_st\n\r");
        break;
      case auto_counter_running_st:
        printf("auto_timer_running_st\n\r");
        break;
      case rate_counter_running_st:
        printf("rate_timer_running_st\n\r");
        break;
      case rate_counter_expired_st:
        printf("rate_timer_expired_st\n\r");
        break;
     }
  }
}


