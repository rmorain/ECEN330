/*
 * buttonHandler.c
 *
 *  Created on: Oct 30, 2016
 *      Author: cdmoo
 */
#include "buttonHandler.h"
#include "simonDisplay.h"
#include "supportFiles/display.h"
#include "supportFiles/utils.h"
#include <stdio.h>

#define TIMER_PERIOD_MS 50
#define ADC_COUNTER_MAX (50 / TIMER_PERIOD_MS)
#define NO_ERASE false
#define ERASE true


static uint8_t regionNumber;
static bool enableFlag;
static bool isReleaseDetected;
static int16_t lastTouchX, lastTouchY;
static uint8_t lastTouchZ;
static void clearFlags();
static void debugStatePrint();

static uint16_t adcCounter;

typedef enum buttonHandler_st_t {
    init_st,
    waiting_for_touch_st,
    adc_counter_running_st,
    is_touching_st,
    end_st
} buttonHandler_st_t;
static buttonHandler_st_t currentState = init_st;

uint8_t buttonHandler_getRegionNumber() {
    return regionNumber;
}

void buttonHandler_enable() {
    enableFlag = true;
}

void buttonHandler_disable() {
    enableFlag = false;
}

bool buttonHandler_releaseDetected() {
    return isReleaseDetected;
}

void buttonHandler_tick() {
    // state action
    switch(currentState) {
        case init_st:
            break;
        case waiting_for_touch_st:
            adcCounter = 0;
            // reset this releaseDetected bool to false so that it stays true for only 1 tick
            isReleaseDetected = false;
            break;
        case adc_counter_running_st:
            adcCounter++;  // in the adc counter running state, increase
            break;
        case is_touching_st:
            adcCounter = 0;
            break;
        case end_st:
            break;
    }

    // transitions
    switch(currentState) {
        case init_st:
            if(enableFlag) {
                //simonDisplay_drawAllButtons();  // if state machine is started, draw the buttons
                currentState = waiting_for_touch_st; // transition to waiting for touch state
            }
            break;
        case waiting_for_touch_st:
            // if the enable flag is taken down, reset teh state machine by transitioning to init state
            // and clearing the board
            if(!enableFlag) {
                //simonDisplay_eraseAllButtons();
                currentState = init_st;
            }
            else if(display_isTouched()) {  // if a touch is detected
                display_clearOldTouchData(); // clear the old touch data
                // and transition to the adc counter state so that the location can be fetched
                currentState = adc_counter_running_st;
            }
            break;
        case adc_counter_running_st:
            // if the enable flag is taken down, reset teh state machine by transitioning to init state
            // and clearing the board
            if(!enableFlag) {
                //simonDisplay_eraseAllButtons();
                currentState = init_st;
            }
            // if the user stops pressing, return to waiting for touch state
            else if(!display_isTouched()) {
                currentState = waiting_for_touch_st;
            }
            // if the user is still pressing and the counter expires
            else if(adcCounter >= ADC_COUNTER_MAX) {
                display_getTouchedPoint(&lastTouchX, &lastTouchY, &lastTouchZ);
                regionNumber = simonDisplay_computeRegionNumber(lastTouchX, lastTouchY); // get the region of the touch
                simonDisplay_drawSquare(regionNumber, NO_ERASE); // draw a sqaure in the appropriate region
                currentState = is_touching_st; // transition to is_touching_state
            }
            break;
        case is_touching_st:
            // if the enable flag is taken down, reset teh state machine by transitioning to init state
            // and clearing the board
            if(!enableFlag) {
                simonDisplay_drawSquare(regionNumber, ERASE);
                //imonDisplay_eraseAllButtons();
                printf("DISABLED WHILE IN IS_TOUCHING_ST");
                currentState = init_st;
            }
            // stay in the is_touching_st until the user is no longer touching
            else if(!display_isTouched()) {
                // one the user has stopped touching, erase the square
                simonDisplay_drawSquare(regionNumber, ERASE);
                simonDisplay_drawButton(regionNumber); // and draw the button in its place
                isReleaseDetected = true; // set the release detected to be true
                currentState = waiting_for_touch_st; // and transition to waiting for touch
            }
            break;
        case end_st:
            if(!enableFlag) {
                //simonDisplay_eraseAllButtons();
                clearFlags();
                currentState = init_st;
            }
            break;
    }

    //debugStatePrint();
}

// clear all flags to reset the state machine
static void clearFlags() {
    isReleaseDetected = false;
    adcCounter = 0;
}

// This is a debug state print routine. It will print the names of the states each
// time tick() is called. It only prints states if they are different than the
// previous state.
static void debugStatePrint() {
  static buttonHandler_st_t previousState;
  static bool firstPass = true;
  // Only print the message if:
  // 1. This the first pass and the value for previousState is unknown.
  // 2. previousState != currentState - this prevents reprinting the same state name over and over.
  if (previousState != currentState || firstPass) {
    firstPass = false;                // previousState will be defined, firstPass is false.
    previousState = currentState;     // keep track of the last state that you were in.
    switch(currentState) {            // This prints messages based upon the state that you were in.
      case init_st:
        printf("init_st\n\r");
        break;
      case waiting_for_touch_st:
        printf("waiting_for_touch_st\n\r");
        break;
      case adc_counter_running_st:
        printf("adc_counter_running_st\n\r");
        break;
      case is_touching_st:
        printf("is_touching_st\n\r");
        break;
      case end_st:
        printf("end_st\n\r");
        break;
     }
  }
}


