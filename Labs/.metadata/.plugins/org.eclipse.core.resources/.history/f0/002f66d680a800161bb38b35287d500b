/*
 * flashSequence.c
 *
 *  Created on: Nov 4, 2016
 *      Author: cdmoo
 */
#include "flashSequence.h"
#include "globals.h"
#include "simonDisplay.h"
#include "supportFiles/display.h"
#include "supportFiles/utils.h"
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

#define DISPLAY_COUNTER_MAX (500 / TICK_PERIOD)
#define ERASE_SQUARE true
#define DRAW_SQUARE false

typedef enum {
    init_st,
    display_new_square_st,
    display_counter_running_st,
    end_st
} flashSequence_state_t;

static flashSequence_state_t currentState = init_st;
static bool enableFlag = false;
static uint16_t displayCounter = 0;
static uint16_t sequenceIterationLength = 0;
static uint16_t currentSequenceIndex = 0;

// Turns on the state machine. Part of the interlock.
void flashSequence_enable() {
    enableFlag = true;
}

// Turns off the state machine. Part of the interlock.
void flashSequence_disable() {
    enableFlag = false;
}

// Other state machines can call this to determine if this state machine is finished.
bool flashSequence_isComplete() {
    return currentState == end_st;
}

// Standard tick function.
void flashSequence_tick() {
    // state actions first
    switch(currentState) {
        case init_st:
            break;
        case display_new_square_st:
            printf("DRAWING SQUARE %d \n", currentSequenceIndex);
            simonDisplay_drawSquare(globals_getSequenceValue(currentSequenceIndex), DRAW_SQUARE);
            break;
        case display_counter_running_st:
            displayCounter++;
            break;
        case end_st:
            break;
    }

    // state transitions
    switch(currentState) {
        case init_st:
            if(enableFlag) {
                sequenceIterationLength = globals_getSequenceIterationLength();
                currentState = display_new_square_st;
            }
            break;
        case display_new_square_st:
            currentState = display_counter_running_st;
            break;
        case display_counter_running_st:
            if(displayCounter > DISPLAY_COUNTER_MAX) {
                displayCounter = 0;
                simonDisplay_drawSquare(globals_getSequenceValue(currentSequenceIndex), ERASE_SQUARE);
                currentSequenceIndex++;
                if(currentSequenceIndex >= sequenceIterationLength) {
                    currentState = end_st;
                } else {
                    currentState = display_new_square_st;
                }
            }
            break;
        case end_st:
            // if enable flag is taken down, reset the counters and wait for the state machine to be re-enabled
            if(!enableFlag) {
                sequenceIterationLength = 0;
                currentSequenceIndex = 0;
                currentState = init_st;
            }
            break;
    }
}





