/*
 * minimax.c
 *
 *  Created on: Oct 6, 2016
 *      Author: cdmoo
 */


#include "minimax.h"
#include <limits.h>
#include <stdio.h>

#define MAX_BOARD_INDEX 2
#define MOVE_SCORE_TABLE_SIZE 10
#define INIT_SCORE_TABLE_VAL -5
#define INIT_MOVE_TABLE_VAL 255
#define STARTING_RECURSION_DEPTH 0
#define CHOICE_INIT_VAL  255
#define CHOICE_INIT_VAL 255
bool verboseScoreLogging = false;
bool verboseRecLogging = false;
//for debugging: number of boards created in a run through of the recursion, reset after each computeNextStep is finished
uint32_t boardCount = 0;

// global variable that is overwritten during each call of minimax but contains the most recent selection
minimax_move_t choice = { .row = CHOICE_INIT_VAL, .column = CHOICE_INIT_VAL };

uint16_t findChoiceIndex(minimax_score_t* scoreTable, bool player);
minimax_score_t minimax_rec(minimax_board_t* board, bool player, uint16_t depth);
void initArrays(minimax_move_t* moveTable, minimax_score_t* scoreTable);
void addMoveToTable(minimax_move_t* moveTable, minimax_move_t move);
void addScoreToTable(minimax_score_t* scoreTable, minimax_score_t score);

void printBoard(minimax_board_t* board) {
    int i, j;
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            if(board->squares[i][j] == MINIMAX_PLAYER_SQUARE) printf("X ");
            else if(board->squares[i][j] == MINIMAX_OPPONENT_SQUARE) printf("O ");
            else printf("  ");
        }
        printf("\n");
    }
    printf("\n");
}

// Determine that the game is over by looking at the score.
bool minimax_isGameOver(minimax_score_t score) {
    return score != MINIMAX_NOT_ENDGAME;
}

// This routine is not recursive but will invoke the recursive minimax function.
// It computes the row and column of the next move based upon:
// the current board,
// the player. true means the computer is X. false means the computer is O.
void minimax_computeNextMove(minimax_board_t* board, bool player, uint8_t* row, uint8_t* column) {
    minimax_rec(board, player, STARTING_RECURSION_DEPTH);
    *row = choice.row;
    *column = choice.column;
    boardCount = 0;
}

minimax_score_t minimax_rec(minimax_board_t* board, bool player, uint16_t depth) {
    if(verboseRecLogging) printf("Invoking minimax @ depth %d  player: %d\n", depth++, player);
    if(verboseRecLogging) printf("**Board %d**\n", ++boardCount);
    if(verboseRecLogging) printBoard(board);
    uint16_t boardNum = boardCount;

    // base case
    minimax_score_t score = minimax_computeBoardScore(board, !player);
    if(minimax_isGameOver(score)) {
        if(verboseRecLogging) printf("Board %d returning endgame w/ score %d\n\n", boardNum, score);
        return minimax_computeBoardScore(board, !player);
    }

    minimax_score_t scoreTable[MOVE_SCORE_TABLE_SIZE];
    minimax_move_t moveTable[MOVE_SCORE_TABLE_SIZE];
    initArrays(moveTable, scoreTable);

    // recursive
    int i, j;
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            if(board->squares[i][j] == MINIMAX_EMPTY_SQUARE) {
                board->squares[i][j] = player ? MINIMAX_PLAYER_SQUARE : MINIMAX_OPPONENT_SQUARE;

                minimax_score_t score = minimax_rec(board, !player, depth);

                // add move to table
                minimax_move_t curMove;
                curMove.row = i;
                curMove.column = j;
                addMoveToTable(moveTable, curMove);

                // add column to table
                addScoreToTable(scoreTable, score);

                //undo the change to the board (return the square to empty)
                board->squares[i][j] = MINIMAX_EMPTY_SQUARE;
            }
        }
    }

    uint16_t index = findChoiceIndex(scoreTable, player);
    if(verboseRecLogging) printf("Board %d returning move %d, %d w/ score %d\n\n", boardNum, moveTable[index].row, moveTable[index].column, scoreTable[index]);
    choice = moveTable[index];
    return scoreTable[index];
}

// Returns the score of the board, based upon the player and the board.
// This returns one of 4 values: MINIMAX_PLAYER_WINNING_SCORE,
// MINIMAX_OPPONENT_WINNING_SCORE, MINIMAX_DRAW_SCORE, MINIMAX_NOT_ENDGAME
// Note: the player argument makes it possible to speed up this function.
// Assumptions:
// (1) if player == true, the last thing played was an 'X'.
// (2) if player == false, the last thing played was an 'O'.
// Hint: If you know the game was not over when an 'X'was played,
// you don't need to look for 'O's, and vice-versa.
minimax_score_t minimax_computeBoardScore(minimax_board_t* board, bool player) {
    // since only either X or O needs to be searched based off the player argument, determin which one will be searched for
    uint16_t valToSearch;
    valToSearch = player ? MINIMAX_PLAYER_SQUARE : MINIMAX_OPPONENT_SQUARE;
    if(verboseScoreLogging) printf("valToSearch: %d\n\n", valToSearch);

    // search for wins in rows, columns, and diagonals
    int i, j, rowCount, columnCount, diagonalCount1, diagonalCount2, nonEmptyCount;
    rowCount = columnCount = diagonalCount1 = diagonalCount2 = nonEmptyCount = 0;
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        if(verboseScoreLogging) printf("checking row: %d\n", i);
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            if(verboseScoreLogging) printf("checking square: %d,%d\n", i,j);
            if(verboseScoreLogging) printf("\tsquare value: %d\n", board->squares[i][j]);

            // search each row
            if(board->squares[i][j] == valToSearch) {
                rowCount++;
                if(verboseScoreLogging) printf("\trowCount++\n");
            }

            // search each column
            if(board->squares[j][i] == valToSearch) {
                columnCount++;
                if(verboseScoreLogging) printf("\tcolumnCount++\n");
            }

            // search diagonal 1 (top right to bottom left)
            if(i == j && board->squares[i][j] == valToSearch) {
                diagonalCount1++;
                if(verboseScoreLogging) printf("\tdiagonalCount1++\n");
            }

            // search diagonal 1 (top left to bottom right)
            if(i + j == MAX_BOARD_INDEX && board->squares[i][j] == valToSearch) {
                diagonalCount2++;
                if(verboseScoreLogging) printf("\tdiagonalCount2++\n");
            }

            // if a square is non zero, it is non empty and should be counted
            if(board->squares[i][j]) {
                nonEmptyCount++;
            }
        }

        if(rowCount == MINIMAX_BOARD_ROWS || columnCount == MINIMAX_BOARD_COLUMNS) {
            return player ? MINIMAX_PLAYER_WINNING_SCORE : MINIMAX_OPPONENT_WINNING_SCORE;
        }
        if(verboseScoreLogging) printf("end row state:\n");
        if(verboseScoreLogging) printf("\trowCount: %d\n", rowCount);
        if(verboseScoreLogging) printf("\tcolumnCount: %d\n", columnCount);
        if(verboseScoreLogging) printf("\tdiagonalCount1: %d\n", diagonalCount1);
        if(verboseScoreLogging) printf("\tdiagonalCount2: %d\n", diagonalCount2);
        if(verboseScoreLogging) printf("resetting row and column count to 0");
        if(verboseScoreLogging) printf("\n\n\n");
        rowCount = columnCount = 0;
    }

    if(diagonalCount1 == MINIMAX_BOARD_ROWS || diagonalCount2 == MINIMAX_BOARD_ROWS) {
        return player ? MINIMAX_PLAYER_WINNING_SCORE : MINIMAX_OPPONENT_WINNING_SCORE;
    }

    if(nonEmptyCount == (MINIMAX_BOARD_COLUMNS * MINIMAX_BOARD_ROWS)) {
        // draw
        return MINIMAX_DRAW_SCORE;
    }

    return MINIMAX_NOT_ENDGAME;
}

// Init the board to all empty squares.
void minimax_initBoard(minimax_board_t* board) {
    int i, j;
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            board->squares[i][j] = MINIMAX_EMPTY_SQUARE;
        }
    }
}

void initArrays(minimax_move_t* moveTable, minimax_score_t* scoreTable) {
    int i;
    for(i = 0; i < MOVE_SCORE_TABLE_SIZE; i++) {
        minimax_move_t tempMove;
        tempMove.row = INIT_MOVE_TABLE_VAL;
        tempMove.column = INIT_MOVE_TABLE_VAL;
        moveTable[i] = tempMove;

        minimax_score_t tempScore = INIT_SCORE_TABLE_VAL;
        scoreTable[i] = tempScore;
    }
}

void addMoveToTable(minimax_move_t* moveTable, minimax_move_t move) {
    int i = 0;
    while(moveTable[i].row != INIT_MOVE_TABLE_VAL) {
        i++;
    }
    moveTable[i] = move;
}

void addScoreToTable(minimax_score_t* scoreTable, minimax_score_t score) {
    int i = 0;
    while(scoreTable[i] != INIT_SCORE_TABLE_VAL) {
        i++;
    }
    scoreTable[i] = score;
}

uint16_t findChoiceIndex(minimax_score_t* scoreTable, bool player) {
    uint16_t lowestIndex, highestIndex;
    int16_t lowestVal = SHRT_MAX;
    int16_t highestVal = SHRT_MIN;
    int i = 0;
    while(scoreTable[i] != INIT_SCORE_TABLE_VAL) {
        if(scoreTable[i] < lowestVal) {
            lowestVal = scoreTable[i];
            lowestIndex = i;
        }
        if(scoreTable[i] > highestVal) {
            highestVal = scoreTable[i];
            highestIndex = i;
        }
        i++;
    }

    return player ? highestIndex : lowestIndex;
}
