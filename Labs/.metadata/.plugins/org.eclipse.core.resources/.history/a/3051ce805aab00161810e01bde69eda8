/*
 * simonControl.c
 *
 *  Created on: Nov 10, 2016
 *      Author: cdmoo
 */
#include "simonControl.h"
#include "globals.h"
#include "supportFiles/display.h"
#include "flashSequence.h"
#include "verifySequence.h"
#include "simonDisplay.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>

#define SEQUENCE_MAX 100  // maximum length of the simon sequence
#define NUMBER_OF_REGIONS 4 // number of touch regions on the game board
#define STARTING_SESSION_SEQUENCE_LENGTH 4 // when the game restarts, this is the length of the sequence
#define STARTING_ITERATION_SEQUENCE_LENGTH 1 // starting length of the the current sequence iteration
#define YAY_WIN_COUNTER_MAX (1500 / TICK_PERIOD) // win state max duration
#define NEW_LEVEL_COUNTER_MAX (3500 / TICK_PERIOD) // new level screen max duration
#define LOSE_MESSAGE_COUNTER_MAX (1500 / TICK_PERIOD) // lose screen max duration
#define LONGEST_SEQUENCE_MESSAGE_COUNTER_MAX (2500 / TICK_PERIOD) // longest sequence message screen max duration
#define TEXT_SIZE_LARGE 4 // largest size of text, used for the game title in the splash screen
#define TEXT_SIZE_SMALL 2 // smallest size of text
#define SPLASH_SCREEN_CURSOR_X 50 // cursor marking the splash screen title
#define SPLASH_SCREEN_CURSOR_Y 70 // cursor marking the splash screen title
#define MESSAGE_SCREEN_CURSOR_X 10 // cursor marking a generic message screen text
#define MESSAGE_SCREEN_CURSOR_Y 100 // cursor marking a generic message screen text
#define ERASE true // flag to draw text in black (erasing it)
#define NO_ERASE false // flag to draw text in white (erasing it)
#define LONGEST_SEQ_MESSAGE_LENGTH 22 // length of the string holding the longest sequence message
#define SEQUENCE_LENGTH_OFFSET 1 // used to calculate the current longest sequence when a user breaks their record


// control SM states
typedef enum {
    init_st, // beginning state, stays here until enabled
    splash_screen_st, // displays the splash screen and waits for user touch
    flashing_sequence_st, // flashes the current sequence iteration to the user
    verifying_sequence_st, // waits for user to repeat the sequence and checks its validity
    yay_win_st, // if the user completes the current session sequence, they are presented with this win message screen
    new_level_feedback_st, // after the win screen, this screen waits for the user to decide if they want a new session
    lose_st, // if there is an error in validation, the user is presented with this lose message screen
    show_longest_sequence_st // before starting a new session, the user is shown this screen with their longest sequence
} simonControl_st_t;

// initialize globals
static simonControl_st_t currentState = init_st; // set the beginning game state to init_st
static uint32_t splashScreenCounter = 0; // set the splash screen counter to 0
// set the iteration sequence length to its starting value
static uint8_t iterationSequenceLength = STARTING_ITERATION_SEQUENCE_LENGTH;
// set the starting session sequence length to its starting value
static uint8_t sessionSequenceLength = STARTING_SESSION_SEQUENCE_LENGTH;
static uint8_t longestSequenceLength = 0; // clear the longest sequence length to -

static void drawSplashScreen(bool); // prototype for a draw splash screen helper function
static void drawWinScreen(bool); // prototype for the draw win screen helper function
static void drawNewLevelFeedbackScreen(bool); // prototype for the draw new level screen helper function
static void drawLongestSequenceScreen(bool erase); // prototype for the draw longest sequence screen helper function
static void drawLoseScreen(bool erase); // prototype for the draw lose screen helper function
static void updateLongestSequenceLength(); // prototype for a helper function that updates the longest sequence record


// intialize state counters to 0
static uint16_t yayWinCounter = 0; // set the win state counter to 0
static uint16_t newLevelCounter = 0; // set the new level counter to 0
static uint16_t loseMessageCounter = 0; // set the lose state counter to 0
static uint16_t longestSequenceMessageCounter = 0; // set the longest message state counter to 0

// creates a new sequence and sets the global sequence to its result
static void generateNewSequence() {
    uint8_t tempSequence[SEQUENCE_MAX]; // creates a temporary array holding the generated sequence
    // iterate through the array, adding a random int to each location
    for(int i = 0; i < SEQUENCE_MAX; i++) {
        tempSequence[i] = rand() % NUMBER_OF_REGIONS; // add a random number % 4 to each location
    }
    globals_setSequence(tempSequence, SEQUENCE_MAX); // pass this sequence to the global module
}

// SM tick function
void simonControl_tick() {
    // state actions
    switch(currentState) {
        case init_st:
            break;
        case splash_screen_st:
            splashScreenCounter++;
            break;
        case flashing_sequence_st:
            break;
        case verifying_sequence_st:
            break;
        case yay_win_st:
            yayWinCounter++;
            break;
        case new_level_feedback_st:
            newLevelCounter++;
            break;
        case lose_st:
            loseMessageCounter++;
            break;
        case show_longest_sequence_st:
            longestSequenceMessageCounter++;
            break;
    }

    // state transitions
    switch(currentState) {
        case init_st:
            drawSplashScreen(NO_ERASE);
            currentState = splash_screen_st;
            break;
        case splash_screen_st:
            if(display_isTouched()) {
                srand(splashScreenCounter);
                drawSplashScreen(ERASE);
                splashScreenCounter = 0;
                generateNewSequence();
                iterationSequenceLength = STARTING_ITERATION_SEQUENCE_LENGTH;
                sessionSequenceLength = STARTING_SESSION_SEQUENCE_LENGTH;
                globals_setSequenceIterationLength(iterationSequenceLength);
                flashSequence_enable();
                currentState = flashing_sequence_st;
            }
            break;
        case flashing_sequence_st:
            if(flashSequence_isComplete()) {
                flashSequence_disable();
                verifySequence_enable();
                simonDisplay_drawAllButtons();
                currentState = verifying_sequence_st;
            }
            break;
        case verifying_sequence_st:
            if(verifySequence_isComplete()) {
                verifySequence_disable();
                simonDisplay_eraseAllButtons();
                if(verifySequence_isTimeOutError() || verifySequence_isUserInputError()) {
                    drawLoseScreen(NO_ERASE);
                    currentState = lose_st;
                } else if(iterationSequenceLength >= sessionSequenceLength) {
                    drawWinScreen(NO_ERASE);
                    updateLongestSequenceLength();
                    currentState = yay_win_st;
                } else {
                    globals_setSequenceIterationLength(++iterationSequenceLength);
                    flashSequence_enable();
                    updateLongestSequenceLength();
                    currentState = flashing_sequence_st;
                }
            }
            break;
        case yay_win_st:
            if(yayWinCounter > YAY_WIN_COUNTER_MAX) {
                yayWinCounter = 0;
                drawWinScreen(ERASE);
                drawNewLevelFeedbackScreen(NO_ERASE);
                currentState = new_level_feedback_st;
            }
            break;
        case new_level_feedback_st:
            if(newLevelCounter > NEW_LEVEL_COUNTER_MAX) {
                newLevelCounter = 0;
                drawNewLevelFeedbackScreen(ERASE);
                drawLongestSequenceScreen(NO_ERASE);
                currentState = show_longest_sequence_st;
            } else if(display_isTouched()) {
                newLevelCounter = 0;
                drawNewLevelFeedbackScreen(ERASE);
                iterationSequenceLength = STARTING_ITERATION_SEQUENCE_LENGTH;
                globals_setSequenceIterationLength(iterationSequenceLength);
                sessionSequenceLength++;
                generateNewSequence();
                flashSequence_enable();
                currentState = flashing_sequence_st;
            }
            break;
        case lose_st:
            if(loseMessageCounter > LOSE_MESSAGE_COUNTER_MAX) {
                loseMessageCounter = 0;
                drawLoseScreen(ERASE);
                drawLongestSequenceScreen(NO_ERASE);
                currentState = show_longest_sequence_st;
            }
            break;
        case show_longest_sequence_st:
            if(longestSequenceMessageCounter > LONGEST_SEQUENCE_MESSAGE_COUNTER_MAX) {
                longestSequenceMessageCounter = 0;
                longestSequenceLength = 0;
                drawLongestSequenceScreen(ERASE);
                drawSplashScreen(NO_ERASE);
                currentState = splash_screen_st;
            }
            break;
    }
    //debugStatePrint();
}

static void drawSplashScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_LARGE);
    display_setCursor(SPLASH_SCREEN_CURSOR_X, SPLASH_SCREEN_CURSOR_Y);
    display_println("  SIMON\n");
    display_setTextSize(TEXT_SIZE_SMALL);
    display_println("      touch to start");
}

static void drawWinScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println("Yay! you win");
}

static void drawNewLevelFeedbackScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println("Touch to start new level");
}

static void drawLongestSequenceScreen(bool erase) {
    static uint16_t lastPrinted;
    char message[LONGEST_SEQ_MESSAGE_LENGTH];
    if(!erase) {
        sprintf(message, "Longest Sequence: %d\n", longestSequenceLength);
        lastPrinted = longestSequenceLength;
    } else {
        sprintf(message, "Longest Sequence: %d\n", lastPrinted);
    }
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println(message);
}

static void drawLoseScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println("Sorry, you lose");
}

static void updateLongestSequenceLength() {
    if(iterationSequenceLength > longestSequenceLength) {
        longestSequenceLength = iterationSequenceLength - SEQUENCE_LENGTH_OFFSET;
    }
}
