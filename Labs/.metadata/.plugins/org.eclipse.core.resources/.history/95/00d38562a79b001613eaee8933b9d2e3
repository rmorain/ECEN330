/*
 * minimax.c
 *
 *  Created on: Oct 6, 2016
 *      Author: cdmoo
 */


#include "minimax.h"
#include <limits.h>
#include <stdio.h>

#define MAX_BOARD_INDEX 2 // highets row / column index on the game boarde
#define MOVE_SCORE_TABLE_SIZE 10 // the size for each move / score array create during recursion
#define INIT_SCORE_TABLE_VAL -5 // value that score arrays are initialized to
#define INIT_MOVE_TABLE_VAL 255 // value that the move arrays are initialized to
#define STARTING_RECURSION_DEPTH 0 // initial depth parameter for recursion
#define CHOICE_INIT_VAL  255 // value that the choice global is initialized to
bool verboseScoreLogging = false;
bool verboseRecLogging = false;
//for debugging: number of boards created in a run through of the recursion, reset after each computeNextStep is finished
uint32_t boardCount = 0;

// global variable that is overwritten during each call of minimax but contains the most recent selection
minimax_move_t choice = { .row = CHOICE_INIT_VAL, .column = CHOICE_INIT_VAL };

// function delcarations -- definitions found below
uint16_t findChoiceIndex(minimax_score_t* scoreTable, bool player);
minimax_score_t minimax_rec(minimax_board_t* board, bool player, uint16_t depth);
void initArrays(minimax_move_t* moveTable, minimax_score_t* scoreTable);
void addMoveToTable(minimax_move_t* moveTable, minimax_move_t move);
void addScoreToTable(minimax_score_t* scoreTable, minimax_score_t score);

// function for debugging that prints a game board
void printBoard(minimax_board_t* board) {
    int i, j;
    // iterate through all of the board rows
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        // iterate through all of the board columns
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            if(board->squares[i][j] == MINIMAX_PLAYER_SQUARE) printf("X "); // print x for player square
            else if(board->squares[i][j] == MINIMAX_OPPONENT_SQUARE) printf("O "); // print O for opponent square
            else printf("  "); // print a space after each board character
        }
        printf("\n");
    }
    printf("\n");
}

// Determine that the game is over by looking at the score.
bool minimax_isGameOver(minimax_score_t score) {
    return score != MINIMAX_NOT_ENDGAME;
}

// This routine is not recursive but will invoke the recursive minimax function.
// It computes the row and column of the next move based upon:
// the current board,
// the player. true means the computer is X. false means the computer is O.
void minimax_computeNextMove(minimax_board_t* board, bool player, uint8_t* row, uint8_t* column) {
    // recurses and stores the new choice in the global choice varaible
    minimax_rec(board, player, STARTING_RECURSION_DEPTH);
    // extract the row value to a global variable
    *row = choice.row;
    // extract the column value to a global variable
    *column = choice.column;
    // reset the global that keeps track of boards created during recursion to 0
    boardCount = 0;
}

// the recursive function that produces all possible board combinations and caclutes the most
// advantageous move for the computer to take
minimax_score_t minimax_rec(minimax_board_t* board, bool player, uint16_t depth) {
    // debugging statements
    if(verboseRecLogging) printf("Invoking minimax @ depth %d  player: %d\n", depth++, player);
    if(verboseRecLogging) printf("**Board %d**\n", ++boardCount);
    // debugging board print
    if(verboseRecLogging) printBoard(board);
    // transfer the blobal value of the board count to give each created board a unique number
    uint16_t boardNum = boardCount;

    // base case of the recursion
        // first, compute the board score
    minimax_score_t score = minimax_computeBoardScore(board, !player);
    // if the board score indicates the the game is over
    if(minimax_isGameOver(score)) {
        if(verboseRecLogging) printf("Board %d returning endgame w/ score %d\n\n", boardNum, score);
        // return the computed score -- passing in !player indicates that the last person to take a move
        // left the board in an end game state -- they won
        return minimax_computeBoardScore(board, !player);
    }

    // if the base case is passed, all possible moves from this board on will be calculated
    // the following arrays represent a move / score table that will keep track of the best
    // possible move
    minimax_score_t scoreTable[MOVE_SCORE_TABLE_SIZE];
    minimax_move_t moveTable[MOVE_SCORE_TABLE_SIZE];
    // init the table with a call to the utility function
    initArrays(moveTable, scoreTable);

    // after creating the tables, recurse on each of the empty squares left in the game
    int i, j;
    // iterate through each row
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        // iterate through each column
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            // check if the swuare is empty
            if(board->squares[i][j] == MINIMAX_EMPTY_SQUARE) {
                // depending on whose turn it is, assign the square to have an x or o value
                board->squares[i][j] = player ? MINIMAX_PLAYER_SQUARE : MINIMAX_OPPONENT_SQUARE;

                // compute the best possible score of this board by recursively calling miminmax
                // on this board, but switching the player (it is the next players turn)
                minimax_score_t score = minimax_rec(board, !player, depth);

                // create a move struct and store the current i and j values (corresponding to
                // row and column values) in the move
                minimax_move_t curMove;
                curMove.row = i;
                curMove.column = j;
                // add the move to the move table
                addMoveToTable(moveTable, curMove);

                // add the score to the score table
                addScoreToTable(scoreTable, score);

                //undo the change to the board (return the square to empty)
                board->squares[i][j] = MINIMAX_EMPTY_SQUARE;
            }
        }
    }

    uint16_t index = findChoiceIndex(scoreTable, player);
    if(verboseRecLogging) printf("Board %d returning move %d, %d w/ score %d\n\n", boardNum, moveTable[index].row, moveTable[index].column, scoreTable[index]);
    choice = moveTable[index];
    return scoreTable[index];
}

// Returns the score of the board, based upon the player and the board.
// This returns one of 4 values: MINIMAX_PLAYER_WINNING_SCORE,
// MINIMAX_OPPONENT_WINNING_SCORE, MINIMAX_DRAW_SCORE, MINIMAX_NOT_ENDGAME
// Note: the player argument makes it possible to speed up this function.
// Assumptions:
// (1) if player == true, the last thing played was an 'X'.
// (2) if player == false, the last thing played was an 'O'.
// Hint: If you know the game was not over when an 'X'was played,
// you don't need to look for 'O's, and vice-versa.
minimax_score_t minimax_computeBoardScore(minimax_board_t* board, bool player) {
    // since only either X or O needs to be searched based off the player argument, determin which one will be searched for
    uint16_t valToSearch;
    valToSearch = player ? MINIMAX_PLAYER_SQUARE : MINIMAX_OPPONENT_SQUARE;
    if(verboseScoreLogging) printf("valToSearch: %d\n\n", valToSearch);

    // search for wins in rows, columns, and diagonals
    int i, j, rowCount, columnCount, diagonalCount1, diagonalCount2, nonEmptyCount;
    rowCount = columnCount = diagonalCount1 = diagonalCount2 = nonEmptyCount = 0;
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        if(verboseScoreLogging) printf("checking row: %d\n", i);
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            if(verboseScoreLogging) printf("checking square: %d,%d\n", i,j);
            if(verboseScoreLogging) printf("\tsquare value: %d\n", board->squares[i][j]);

            // search each row
            if(board->squares[i][j] == valToSearch) {
                rowCount++;
                if(verboseScoreLogging) printf("\trowCount++\n");
            }

            // search each column
            if(board->squares[j][i] == valToSearch) {
                columnCount++;
                if(verboseScoreLogging) printf("\tcolumnCount++\n");
            }

            // search diagonal 1 (top right to bottom left)
            if(i == j && board->squares[i][j] == valToSearch) {
                diagonalCount1++;
                if(verboseScoreLogging) printf("\tdiagonalCount1++\n");
            }

            // search diagonal 1 (top left to bottom right)
            if(i + j == MAX_BOARD_INDEX && board->squares[i][j] == valToSearch) {
                diagonalCount2++;
                if(verboseScoreLogging) printf("\tdiagonalCount2++\n");
            }

            // if a square is non zero, it is non empty and should be counted
            if(board->squares[i][j]) {
                nonEmptyCount++;
            }
        }

        if(rowCount == MINIMAX_BOARD_ROWS || columnCount == MINIMAX_BOARD_COLUMNS) {
            return player ? MINIMAX_PLAYER_WINNING_SCORE : MINIMAX_OPPONENT_WINNING_SCORE;
        }
        if(verboseScoreLogging) printf("end row state:\n");
        if(verboseScoreLogging) printf("\trowCount: %d\n", rowCount);
        if(verboseScoreLogging) printf("\tcolumnCount: %d\n", columnCount);
        if(verboseScoreLogging) printf("\tdiagonalCount1: %d\n", diagonalCount1);
        if(verboseScoreLogging) printf("\tdiagonalCount2: %d\n", diagonalCount2);
        if(verboseScoreLogging) printf("resetting row and column count to 0");
        if(verboseScoreLogging) printf("\n\n\n");
        rowCount = columnCount = 0;
    }

    if(diagonalCount1 == MINIMAX_BOARD_ROWS || diagonalCount2 == MINIMAX_BOARD_ROWS) {
        return player ? MINIMAX_PLAYER_WINNING_SCORE : MINIMAX_OPPONENT_WINNING_SCORE;
    }

    if(nonEmptyCount == (MINIMAX_BOARD_COLUMNS * MINIMAX_BOARD_ROWS)) {
        // draw
        return MINIMAX_DRAW_SCORE;
    }

    return MINIMAX_NOT_ENDGAME;
}

// Init the board to all empty squares.
void minimax_initBoard(minimax_board_t* board) {
    int i, j;
    for(i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        for(j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            board->squares[i][j] = MINIMAX_EMPTY_SQUARE;
        }
    }
}

void initArrays(minimax_move_t* moveTable, minimax_score_t* scoreTable) {
    int i;
    for(i = 0; i < MOVE_SCORE_TABLE_SIZE; i++) {
        minimax_move_t tempMove;
        tempMove.row = INIT_MOVE_TABLE_VAL;
        tempMove.column = INIT_MOVE_TABLE_VAL;
        moveTable[i] = tempMove;

        minimax_score_t tempScore = INIT_SCORE_TABLE_VAL;
        scoreTable[i] = tempScore;
    }
}

void addMoveToTable(minimax_move_t* moveTable, minimax_move_t move) {
    int i = 0;
    while(moveTable[i].row != INIT_MOVE_TABLE_VAL) {
        i++;
    }
    moveTable[i] = move;
}

void addScoreToTable(minimax_score_t* scoreTable, minimax_score_t score) {
    int i = 0;
    while(scoreTable[i] != INIT_SCORE_TABLE_VAL) {
        i++;
    }
    scoreTable[i] = score;
}

uint16_t findChoiceIndex(minimax_score_t* scoreTable, bool player) {
    uint16_t lowestIndex, highestIndex;
    int16_t lowestVal = SHRT_MAX;
    int16_t highestVal = SHRT_MIN;
    int i = 0;
    while(scoreTable[i] != INIT_SCORE_TABLE_VAL) {
        if(scoreTable[i] < lowestVal) {
            lowestVal = scoreTable[i];
            lowestIndex = i;
        }
        if(scoreTable[i] > highestVal) {
            highestVal = scoreTable[i];
            highestIndex = i;
        }
        i++;
    }

    return player ? highestIndex : lowestIndex;
}
