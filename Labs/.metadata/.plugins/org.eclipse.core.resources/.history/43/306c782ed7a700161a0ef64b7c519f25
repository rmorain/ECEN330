/*
 * simonControl.c
 *
 *  Created on: Nov 10, 2016
 *      Author: cdmoo
 */
#include "simonControl.h"
#include "globals.h"
#include "supportFiles/display.h"
#include "flashSequence.h"
#include "verifySequence.h"
#include "simonDisplay.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>

#define SEQUENCE_MAX 100
#define NUMBER_OF_REGIONS 4
#define STARTING_SESSION_SEQUENCE_LENGTH 4
#define STARTING_ITERATION_SEQUENCE_LENGTH 1
#define YAY_WIN_COUNTER_MAX (5000 / TICK_PERIOD)
#define NEW_LEVEL_COUNTER_MAX (5000 / TICK_PERIOD)
#define LOSE_MESSAGE_COUNTER_MAX (5000 / TICK_PERIOD)
#define LONGEST_SEQUENCE_MESSAGE_COUNTER_MAX (5000 / TICK_PERIOD)
#define TEXT_SIZE_LARGE 4
#define TEXT_SIZE_SMALL 2
#define SPLASH_SCREEN_CURSOR_X 50
#define SPLASH_SCREEN_CURSOR_Y 70
#define MESSAGE_SCREEN_CURSOR_X 30
#define MESSAGE_SCREEN_CURSOR_Y 100
#define ERASE true
#define NO_ERASE false
#define LONGEST_SEQ_MESSAGE_LENGTH 50


typedef enum {
    init_st,
    splash_screen_st,
    flashing_sequence_st,
    verifying_sequence_st,
    yay_win_st,
    new_level_feedback_st,
    lose_st,
    show_longest_sequence_st
} simonControl_st_t;

static simonControl_st_t currentState = init_st;
static uint32_t splashScreenCounter = 0;
static uint8_t iterationSequenceLength = STARTING_ITERATION_SEQUENCE_LENGTH;
static uint8_t sessionSequenceLength = STARTING_SESSION_SEQUENCE_LENGTH;
static uint8_t longestSequenceLength = 0;
static void debugStatePrint();
static void drawSplashScreen(bool);
static void drawWinScreen(bool);
static void drawNewLevelFeedbackScreen(bool);
static void drawLongestSequenceScreen(bool erase);
static void drawLoseScreen(bool erase);


static uint16_t yayWinCounter = 0;
static uint16_t newLevelCounter = 0;
static uint16_t loseMessageCounter = 0;
static uint16_t longestSequenceMessageCounter = 0;

// creates a new sequence and sets the global sequence to its result
static void generateNewSequence() {
    uint8_t tempSequence[SEQUENCE_MAX];
    for(int i = 0; i < SEQUENCE_MAX; i++) {
        tempSequence[i] = rand() % NUMBER_OF_REGIONS;
    }
    globals_setSequence(tempSequence, SEQUENCE_MAX);
}

void simonControl_tick() {
    // state actions
    switch(currentState) {
        case init_st:
            display_init();                   // We are using the display.
            display_fillScreen(DISPLAY_BLACK);    // Clear the display.
            break;
        case splash_screen_st:
            splashScreenCounter++;
            break;
        case flashing_sequence_st:
            break;
        case verifying_sequence_st:
            break;
        case yay_win_st:
            yayWinCounter++;
            break;
        case new_level_feedback_st:
            newLevelCounter++;
            break;
        case lose_st:
            loseMessageCounter++;
            break;
        case show_longest_sequence_st:
            longestSequenceMessageCounter++;
            break;
    }

    // state transitions
    switch(currentState) {
        case init_st:
            drawSplashScreen(NO_ERASE);
            currentState = splash_screen_st;
            break;
        case splash_screen_st:
            if(display_isTouched()) {
                srand(splashScreenCounter);
                drawSplashScreen(ERASE);
                splashScreenCounter = 0;
                generateNewSequence();
                iterationSequenceLength = STARTING_ITERATION_SEQUENCE_LENGTH;
                sessionSequenceLength = STARTING_SESSION_SEQUENCE_LENGTH;
                globals_setSequenceIterationLength(iterationSequenceLength);
                flashSequence_enable();
                currentState = flashing_sequence_st;
            }
            break;
        case flashing_sequence_st:
            if(flashSequence_isComplete()) {
                flashSequence_disable();
                verifySequence_enable();
                simonDisplay_drawAllButtons();
                currentState = verifying_sequence_st;
            }
            break;
        case verifying_sequence_st:
            if(verifySequence_isComplete()) {
                verifySequence_disable();
                simonDisplay_eraseAllButtons();
                if(verifySequence_isTimeOutError() || verifySequence_isUserInputError()) {
                    drawLoseScreen(NO_ERASE);
                    currentState = lose_st;
                } else if(iterationSequenceLength >= sessionSequenceLength) {
                    longestSequenceLength = sessionSequenceLength; // update longest acheived sequence length
                    drawWinScreen(NO_ERASE);
                    currentState = yay_win_st;
                } else {
                    globals_setSequenceIterationLength(++iterationSequenceLength);
                    flashSequence_enable();
                    currentState = flashing_sequence_st;
                }
            }
            break;
        case yay_win_st:
            if(yayWinCounter > YAY_WIN_COUNTER_MAX) {
                yayWinCounter = 0;
                drawWinScreen(ERASE);
                drawNewLevelFeedbackScreen(NO_ERASE);
                currentState = new_level_feedback_st;
            }
            break;
        case new_level_feedback_st:
            if(newLevelCounter > NEW_LEVEL_COUNTER_MAX) {
                newLevelCounter = 0;
                drawNewLevelFeedbackScreen(ERASE);
                currentState = show_longest_sequence_st;
            } else if(display_isTouched()) {
                newLevelCounter = 0;
                drawNewLevelFeedbackScreen(ERASE);
                iterationSequenceLength = STARTING_ITERATION_SEQUENCE_LENGTH;
                globals_setSequenceIterationLength(iterationSequenceLength);
                sessionSequenceLength++;
                generateNewSequence();
                flashSequence_enable();
                currentState = flashing_sequence_st;
            }
            break;
        case lose_st:
            if(loseMessageCounter > LOSE_MESSAGE_COUNTER_MAX) {
                loseMessageCounter = 0;
                drawLoseScreen(ERASE);
                drawLongestSequenceScreen(ERASE);
                currentState = show_longest_sequence_st;
            }
            break;
        case show_longest_sequence_st:
            if(longestSequenceMessageCounter > LONGEST_SEQUENCE_MESSAGE_COUNTER_MAX) {
                longestSequenceMessageCounter = 0;
                drawLongestSequenceScreen(ERASE);
                drawSplashScreen(NO_ERASE);
                currentState = splash_screen_st;
            }
            break;
    }
    debugStatePrint();
}

static void drawSplashScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_LARGE);
    display_setCursor(SPLASH_SCREEN_CURSOR_X, SPLASH_SCREEN_CURSOR_Y);
    display_println("  SIMON\n");
    display_setTextSize(TEXT_SIZE_SMALL);
    display_println("      touch to start");
}

static void drawWinScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println("Yay! you win");
}

static void drawNewLevelFeedbackScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println("touch to start a new level");
}

static void drawLongestSequenceScreen(bool erase) {
    char message[LONGEST_SEQ_MESSAGE_LENGTH];
    sprintf(message, "Longest Sequence: %d", longestSequenceLength);
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println(message);
}

static void drawLoseScreen(bool erase) {
    erase ? display_setTextColor(DISPLAY_BLACK) : display_setTextColor(DISPLAY_WHITE);
    display_setTextSize(TEXT_SIZE_SMALL);
    display_setCursor(MESSAGE_SCREEN_CURSOR_X, MESSAGE_SCREEN_CURSOR_Y);
    display_println("Sorry, you lose");
}

// This is a debug state print routine. It will print the names of the states each
// time tick() is called. It only prints states if they are different than the
// previous state.
static void debugStatePrint() {
  static simonControl_st_t previousState;
  static bool firstPass = true;
  // Only print the message if:
  // 1. This the first pass and the value for previousState is unknown.
  // 2. previousState != currentState - this prevents reprinting the same state name over and over.
  if (previousState != currentState || firstPass) {
    firstPass = false;                // previousState will be defined, firstPass is false.
    previousState = currentState;     // keep track of the last state that you were in.
    switch(currentState) {            // This prints messages based upon the state that you were in.
      case init_st:
          printf("init_st\n\r");
          break;
      case splash_screen_st:
          printf("splash_screen_st\n\r");
          break;
      case flashing_sequence_st:
          printf("flashing_sequence_st\n\r");
          break;
      case verifying_sequence_st:
          printf("verifying_sequence_st\n\r");
          break;
      case yay_win_st:
          printf("yay_win_st\n\r");
          break;
      case new_level_feedback_st:
          printf("new_level_feedback_st\n\r");
          break;
      case lose_st:
          printf("lose_st\n\r");
          break;
      case show_longest_sequence_st:
          printf("show_longest_sequence_st\n\r");
          break;
     }
  }
}


