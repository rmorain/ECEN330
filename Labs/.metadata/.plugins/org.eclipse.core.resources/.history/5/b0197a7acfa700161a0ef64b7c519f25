/*
 * verifySequence.c
 *
 *  Created on: Nov 5, 2016
 *      Author: cdmoo
 */

#include "verifySequence.h"
#include "buttonHandler.h"
#include "globals.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>

#define TIMEOUT_COUNTER_MAX 30

static bool enableFlag = false;
static bool isTimeOutError = false;
static bool isUserInputError = false;
static uint16_t timeoutCounter = 0;
static uint8_t lastTouchedRegionNumber;

static uint16_t sequenceIterationLength = 0;
static uint16_t currentSequenceIndex = 0;

static void resetFlags();
static void debugStatePrint();

typedef enum {
    init_st,
    waiting_user_input_st,
    verify_user_input_st,
    end_st
} verifySequence_state_t;

static verifySequence_state_t currentState = init_st;

// State machine will run when enabled.
void verifySequence_enable() {
    enableFlag = true;
}

// This is part of the interlock. You disable the state-machine and then enable it again.
void verifySequence_disable() {
    enableFlag = false;
}

// Used to detect if there has been a time-out error.
bool verifySequence_isTimeOutError() {
    return isTimeOutError;
}

// Used to detect if the user tapped the incorrect sequence.
bool verifySequence_isUserInputError() {
    return isUserInputError;
}

// Used to detect if the verifySequence state machine has finished verifying.
bool verifySequence_isComplete() {
    return currentState == end_st;
}

// Standard tick function.
void verifySequence_tick() {
    // state actions
    switch(currentState) {
        case init_st:
            break;
        case waiting_user_input_st:
            timeoutCounter++;
            break;
        case verify_user_input_st:
            timeoutCounter = 0;
            break;
        case end_st:
            break;
    }

    // transitions
    switch(currentState) {
        case init_st:
            if(enableFlag) {
                simonDisplay_drawButtons();
                buttonHandler_enable();
                sequenceIterationLength = globals_getSequenceIterationLength();
                currentState = waiting_user_input_st;
            }
            break;
        case waiting_user_input_st:
            if(timeoutCounter > TIMEOUT_COUNTER_MAX) {
                isTimeOutError = true;
                buttonHandler_disable();
                currentState = end_st;
            } else if(buttonHandler_releaseDetected()) {
                lastTouchedRegionNumber = buttonHandler_getRegionNumber();
                buttonHandler_disable();
                currentState = verify_user_input_st;
            }
            break;
        case verify_user_input_st:
            // first check if user input is correct
            if(lastTouchedRegionNumber == globals_getSequenceValue(currentSequenceIndex++)) {
                if(currentSequenceIndex < sequenceIterationLength) {
                    buttonHandler_enable();
                    currentState = waiting_user_input_st;
                } else {
                    buttonHandler_disable();
                    currentState = end_st;
                }
            } else {
                buttonHandler_disable();
                isUserInputError = true;
                currentState = end_st;
            }
            break;
        case end_st:
            if(!enableFlag) {
                resetFlags();
                currentState = init_st;
            }
            break;
    }

    //debugStatePrint();
}

static void resetFlags() {
    sequenceIterationLength = 0;
    currentSequenceIndex = 0;
    isTimeOutError = false;
    isUserInputError = false;
    timeoutCounter = 0;
}


// This is a debug state print routine. It will print the names of the states each
// time tick() is called. It only prints states if they are different than the
// previous state.
static void debugStatePrint() {
  static verifySequence_state_t previousState;
  static bool firstPass = true;
  // Only print the message if:
  // 1. This the first pass and the value for previousState is unknown.
  // 2. previousState != currentState - this prevents reprinting the same state name over and over.
  if (previousState != currentState || firstPass) {
    firstPass = false;                // previousState will be defined, firstPass is false.
    previousState = currentState;     // keep track of the last state that you were in.
    switch(currentState) {            // This prints messages based upon the state that you were in.
      case init_st:
        printf("init_st\n\r");
        break;
      case waiting_user_input_st:
        printf("waiting_user_input_st\n\r");
        break;
      case verify_user_input_st:
        printf("verify_user_input_st\n\r");
        break;
      case end_st:
        printf("end_st\n\r");
        break;
     }
  }
}


