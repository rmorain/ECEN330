/*
 * ticTacToeControl.c
 *
 *  Created on: Oct 22, 2016
 *      Author: cdmoo
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include "ticTacToeDisplay.h"
#include "supportFiles/display.h"
#include "minimax.h"
#include "minimaxTest.h"
#include "../switchesAndButtons/buttons.h"
#include "../intervalTimer/intervalTimer.h"

#define TIMER_PERIOD 50 // the current period of each interrupt
// the maximum time in ms of the adc counter divided by the interrupt period
// to determine the number of ticks to stay in that state
#define ADC_COUNTER_MAX (50 / TIMER_PERIOD)
// the maximum time in ms of the splash screen counter divided by the interrupt period
// to determine the number of ticks to stay in that state
#define SPLASH_SCREEN_COUNTER_MAX (3000 / TIMER_PERIOD)
// the maximum time in ms of the first move counter divided by the interrupt period
// to determine the number of ticks to stay in that state
#define FIRST_MOVE_COUNTER_MAX (3000 / TIMER_PERIOD)


// States for the controller state machine.
typedef enum gameControl_st_t {
    init_st,                 // Start here, stay in this state for just one tick.
    splash_screen_st,       // state for displaying the instructions message before the game begins
    waiting_first_move_st,   // state for waiting on the player to make the first move (else computer makes first move)
    adc_counter_running_st,     // waiting for the touch-controller ADC to settle.
    player_turn_waiting_st,    // waiting for the player to make a move
    evaluate_player_move_st,   // state that determines validity of move, returning control to player if move was invalid
    computer_turn_st,  // state waiting for computer to make move
    end_game_st  // state at the end of the game, waiting for reset button to be pressed
} gameControl_st_t;
// initialize the state to initState
static gameControl_st_t currentState = init_st;

static uint32_t adcCounter; // global keeping tracks of ticks in the adc state
static uint32_t splashScreenCounter; // global keeping tracks of ticks in the splash screen state
static uint32_t firstMoveCounter; // global keeping tack of the waiting for the first move state

static bool isPlayerTurn; // global keeping track of whose turn it is
static bool isPlayerX; // global keeping track of whose playing which character
static minimax_board_t gameBoard; // global game board used for keeping track of game state
static minimax_move_t computerNextMove; // global holding the computers calculated next move
static minimax_move_t playerNextMove; // global keeping track of the players next move
static minimax_score_t currentScore; // global keeping track of score

static void debugStatePrint();
static bool isPlayerMoveValid();
static void playNextMove();
static bool resetGame();
static void eraseGameBoard();

void ticTacToeControl_tick() {
    //perform state action first
    switch(currentState) {
        case init_st:
            intervalTimer_init(0);
            break;
        case splash_screen_st:
            splashScreenCounter++;
            break;
        case waiting_first_move_st:
            firstMoveCounter++;
            break;
        case adc_counter_running_st:
            adcCounter++;
            break;
        case player_turn_waiting_st:
            isPlayerTurn = true;
            break;
        case evaluate_player_move_st:
            ticTacToeDisplay_touchScreenComputeBoardRowColumn(&playerNextMove.row, &playerNextMove.column);
            currentScore = minimax_computeBoardScore(&gameBoard, isPlayerX);
            break;
        case computer_turn_st:
            isPlayerTurn = false;
            minimax_computeNextMove(&gameBoard, !isPlayerX, &computerNextMove.row, &computerNextMove.column);
            playNextMove();
            currentScore = minimax_computeBoardScore(&gameBoard, !isPlayerX);
            break;
        case end_game_st:
            break;
    }

    // perform state update next
    switch(currentState) {
        case init_st:
            //ticTacToeDisplay_drawSplashScreen();
            currentState = splash_screen_st;
            break;
        case splash_screen_st:
            if(splashScreenCounter >= SPLASH_SCREEN_COUNTER_MAX) {
                ticTacToeDisplay_clearSplashScreen();
                ticTacToeDisplay_drawBoardLines();
                minimax_initBoard(&gameBoard);
                currentState = waiting_first_move_st;
            }
            break;
        case waiting_first_move_st:
            if(display_isTouched()) {
                isPlayerX = true;
                isPlayerTurn = true;
                display_clearOldTouchData();
                currentState = adc_counter_running_st;
            } else if(firstMoveCounter >= FIRST_MOVE_COUNTER_MAX) {
                isPlayerX = false;
                currentState = computer_turn_st;
            }
            break;
        case adc_counter_running_st:
            if(!display_isTouched() && adcCounter >= ADC_COUNTER_MAX) {
                currentState = player_turn_waiting_st;
            } else if(display_isTouched() && adcCounter >= ADC_COUNTER_MAX) {
                currentState = evaluate_player_move_st;
            }
            break;
        case player_turn_waiting_st:
            if(display_isTouched()) {
                display_clearOldTouchData();
                currentState = adc_counter_running_st;
            }
            break;
        case computer_turn_st:
            if(minimax_isGameOver(currentScore)) {
                currentState = end_game_st;
            } else {
                currentState = player_turn_waiting_st;
            }
            break;
        case evaluate_player_move_st:
            if(minimax_isGameOver(currentScore)) {
                currentState = end_game_st;
            } else if(isPlayerMoveValid()) {
                playNextMove();
                currentState = computer_turn_st;
            } else {
                currentState = player_turn_waiting_st;
            }
            break;
        case end_game_st:
            if(resetGame()) {
                eraseGameBoard();
                minimax_initBoard(&gameBoard);
                currentState = waiting_first_move_st;
                adcCounter = 0;
                splashScreenCounter = 0;
                firstMoveCounter = 0;
                currentScore = 0;
            }
            break;
    }
    //debugStatePrint();
}

// helper function that contains logic for putting the next move onto the board
static void playNextMove() {
    // if it is the players turn
    if(isPlayerTurn) {
        // if the player is playing x
        if(isPlayerX) {
            // mark the appropriate square with an x
            gameBoard.squares[playerNextMove.row][playerNextMove.column] = MINIMAX_PLAYER_SQUARE;
            // draw the move
            ticTacToeDisplay_drawX(playerNextMove.row, playerNextMove.column, false);
        } else {
            // mark the appropriate square with an o
            gameBoard.squares[playerNextMove.row][playerNextMove.column] = MINIMAX_OPPONENT_SQUARE;
            // draw the move
            ticTacToeDisplay_drawO(playerNextMove.row, playerNextMove.column, false);
        }
        // draw the computers move
    } else {
        // if the computer is playing x
        if(!isPlayerX) {
            // mark the appropriate square with an x
            gameBoard.squares[computerNextMove.row][computerNextMove.column] = MINIMAX_PLAYER_SQUARE;
            // draw the move
            ticTacToeDisplay_drawX(computerNextMove.row, computerNextMove.column, false);
        } else {
            // mark the appropriate sqaure with an o
            gameBoard.squares[computerNextMove.row][computerNextMove.column] = MINIMAX_OPPONENT_SQUARE;
            // draw the move
            ticTacToeDisplay_drawO(computerNextMove.row, computerNextMove.column, false);
        }
    }
}


static bool isPlayerMoveValid() {
    return !gameBoard.squares[playerNextMove.row][playerNextMove.column];
}

static bool resetGame() {
    return buttons_read() & BUTTONS_BTN0_MASK;
}

static void eraseGameBoard() {
    for(int i = 0; i < MINIMAX_BOARD_ROWS; i++) {
        for(int j = 0; j < MINIMAX_BOARD_COLUMNS; j++) {
            if(gameBoard.squares[i][j]) {
                ticTacToeDisplay_drawX(i, j, true);
                ticTacToeDisplay_drawO(i, j, true);
            }
        }
    }
}


// This is a debug state print routine. It will print the names of the states each
// time tick() is called. It only prints states if they are different than the
// previous state.
static void debugStatePrint() {


  static gameControl_st_t previousState;
  static bool firstPass = true;
  // Only print the message if:
  // 1. This the first pass and the value for previousState is unknown.
  // 2. previousState != currentState - this prevents reprinting the same state name over and over.
  if (previousState != currentState || firstPass) {
    firstPass = false;                // previousState will be defined, firstPass is false.
    previousState = currentState;     // keep track of the last state that you were in.
    switch(currentState) {            // This prints messages based upon the state that you were in.
      case init_st:
        printf("init_st\n\r");
        break;
      case splash_screen_st:
        printf("splash_screen_st\n\r");
        break;
      case waiting_first_move_st:
        printf("waiting_first_move_st\n\r");
        break;
      case adc_counter_running_st:
        printf("adc_counter_running_st\n\r");
        break;
      case player_turn_waiting_st:
        printf("player_turn_waiting_st\n\r");
        break;
      case computer_turn_st:
        printf("computer_turn_st\n\r");
        break;
      case evaluate_player_move_st:
        printf("eval_player_move_st\n\r");
        break;
      case end_game_st:
        printf("end_game_st\n\r");
        break;
     }
  }
}


